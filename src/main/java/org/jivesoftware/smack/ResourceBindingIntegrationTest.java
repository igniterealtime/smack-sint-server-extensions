/**
 * Copyright 2023 Ignite Realtime Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.jivesoftware.smack;

import org.igniterealtime.smack.inttest.AbstractSmackLowLevelIntegrationTest;
import org.igniterealtime.smack.inttest.SmackIntegrationTestEnvironment;
import org.igniterealtime.smack.inttest.annotations.SmackIntegrationTest;
import org.igniterealtime.smack.inttest.util.ResultSyncPoint;
import org.jivesoftware.smack.packet.Message;
import org.jivesoftware.smack.packet.StanzaBuilder;
import org.jivesoftware.smack.packet.StreamError;
import org.jivesoftware.smack.util.StringUtils;
import org.jxmpp.jid.Jid;
import org.jxmpp.jid.impl.JidCreate;
import org.jxmpp.jid.parts.Localpart;

import java.io.IOException;
import java.util.concurrent.atomic.AtomicReference;

import static org.junit.jupiter.api.Assertions.*;

public class ResourceBindingIntegrationTest extends AbstractSmackLowLevelIntegrationTest
{
    public ResourceBindingIntegrationTest(SmackIntegrationTestEnvironment environment) {
        super(environment);
    }

    /**
     * Asserts that the stream is closed with a 'not_authorized' stream error when a message is sent to a user different
     * from the user that is using the connection, before the user authenticates.
     *
     * <p>From RFC-6120 ยง 7.1:</p>
     * <blockquote>
     * If, before completing the resource binding step, the client attempts
     * to send an XML stanza to an entity other than the server itself or
     * the client's account, the server MUST NOT process the stanza and MUST
     * close the stream with a <not-authorized/> stream error
     * (Section 4.9.3.12).
     * </blockquote>
     *
     * Ideally, we'd test this (too) after authentication but before resource binding, but the Smack API does not
     * support this.
     *
     * @throws InterruptedException if the calling thread was interrupted.
     * @throws XMPPException if an XMPP protocol error was received.
     * @throws IOException if an I/O error occurred.
     * @throws SmackException if Smack detected an exceptional situation.
     */
    @SmackIntegrationTest
    public void testMessageBeforeLogin() throws XMPPException, SmackException, IOException, InterruptedException
    {
        final String nonExistentUserString = StringUtils.insecureRandomString(24);

        AbstractXMPPConnection connection = getUnconnectedConnection();
        connection.connect();

        final Jid nonExistentUser = JidCreate.bareFrom(Localpart.from(nonExistentUserString), connection.getXMPPServiceDomain().getDomain());

        try {
            final Message message = StanzaBuilder.buildMessage()
                .to(nonExistentUser)
                .setBody("Generated by Smack integration test as implemented in " + getClass())
                .build();

            final ResultSyncPoint<XMPPException.StreamErrorException, Exception> errorReceived = new ResultSyncPoint<>();
            final ConnectionListener listener = new ConnectionListener() {
                @Override
                public void connectionClosedOnError(Exception e) {
                    if (e instanceof XMPPException.StreamErrorException) {
                        errorReceived.signal((XMPPException.StreamErrorException) e); // Expected
                    } else {
                        errorReceived.signal(new Exception("Smack threw an error other than the expected StreamErrorException", e));
                    }
                }

                @Override
                public void connectionClosed() {
                    errorReceived.signal(new Exception("Connection closed without error"));
                }
            };

            connection.addConnectionListener(listener);
            connection.sendStanza(message);

            final AtomicReference<XMPPException.StreamErrorException> result = new AtomicReference<>();
            assertDoesNotThrow(() -> result.set(errorReceived.waitForResult(timeout)));
            assertNotNull(result.get());
            final StreamError streamError = result.get().getStreamError();
            assertEquals(StreamError.Condition.not_authorized, streamError.getCondition());
        } finally {
            connection.disconnect();
        }
    }
}
