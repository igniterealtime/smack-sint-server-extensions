/**
 * Copyright 2023 Ignite Realtime Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.jivesoftware.smack;

import org.igniterealtime.smack.inttest.AbstractSmackLowLevelIntegrationTest;
import org.igniterealtime.smack.inttest.SmackIntegrationTestEnvironment;
import org.igniterealtime.smack.inttest.annotations.SmackIntegrationTest;
import org.igniterealtime.smack.inttest.util.ResultSyncPoint;
import org.jivesoftware.smack.filter.*;
import org.jivesoftware.smack.packet.*;
import org.jivesoftware.smack.util.StringUtils;
import org.jivesoftware.smackx.iqversion.packet.Version;
import org.jxmpp.jid.BareJid;
import org.jxmpp.jid.DomainBareJid;
import org.jxmpp.jid.Jid;
import org.jxmpp.jid.impl.JidCreate;
import org.jxmpp.jid.parts.Localpart;

import java.io.IOException;
import java.util.concurrent.atomic.AtomicReference;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Tests that verify the behavior of Openfire around resource binding.
 *
 * @author Guus der Kinderen, guus.der.kinderen@gmail.com
 */
public class ResourceBindingIntegrationTest extends AbstractSmackLowLevelIntegrationTest {

    public ResourceBindingIntegrationTest(SmackIntegrationTestEnvironment environment) {
        super(environment);
    }

    /**
     * Asserts that the stream is closed with a 'not_authorized' stream error when a stanza is sent to a user different
     * from the user that is using the connection, before the user authenticates.
     *
     * <p>From RFC-6120 ยง 7.1:</p>
     * <blockquote>
     * If, before completing the resource binding step, the client attempts
     * to send an XML stanza to an entity other than the server itself or
     * the client's account, the server MUST NOT process the stanza and MUST
     * close the stream with a <not-authorized/> stream error
     * (Section 4.9.3.12).
     * </blockquote>
     *
     * Ideally, we'd test this (too) after authentication but before resource binding, but the Smack API does not
     * support this.
     *
     * @throws InterruptedException if the calling thread was interrupted.
     * @throws XMPPException if an XMPP protocol error was received.
     * @throws IOException if an I/O error occurred.
     * @throws SmackException if Smack detected an exceptional situation.
     * @see <a href="https://igniterealtime.atlassian.net/jira/software/c/projects/OF/issues/OF-2565">issue OF-2565</a>
     */
    @SmackIntegrationTest
    public void testSendStanzaBeforeLoginToSomeoneElse() throws XMPPException, SmackException, IOException, InterruptedException
    {
        final String nonExistentUserString = StringUtils.insecureRandomString(24);

        final AbstractXMPPConnection connection = getUnconnectedConnection();
        connection.connect();

        final Jid nonExistentUser = JidCreate.bareFrom(Localpart.from(nonExistentUserString), connection.getXMPPServiceDomain().getDomain());

        try {
            final Message message = StanzaBuilder.buildMessage()
                .to(nonExistentUser)
                .setBody("Generated by Smack integration test as implemented in " + getClass())
                .build();

            final ResultSyncPoint<XMPPException.StreamErrorException, Exception> errorReceived = new ResultSyncPoint<>();
            final ConnectionListener listener = new ConnectionListener() {
                @Override
                public void connectionClosedOnError(Exception e) {
                    if (e instanceof XMPPException.StreamErrorException) {
                        errorReceived.signal((XMPPException.StreamErrorException) e); // Expected
                    } else {
                        errorReceived.signal(new Exception("Smack threw an error other than the expected StreamErrorException", e));
                    }
                }

                @Override
                public void connectionClosed() {
                    errorReceived.signal(new Exception("Connection closed without error"));
                }
            };

            connection.addConnectionListener(listener);
            connection.sendStanza(message);

            final AtomicReference<XMPPException.StreamErrorException> result = new AtomicReference<>();
            assertDoesNotThrow(() -> result.set(errorReceived.waitForResult(timeout)));
            assertNotNull(result.get());
            final StreamError streamError = result.get().getStreamError();
            assertEquals(StreamError.Condition.not_authorized, streamError.getCondition());
        } finally {
            connection.disconnect();
        }
    }

    /**
     * Asserts that the stream is NOT closed (with a 'not_authorized' stream error) when a stanza is sent to 'yourself',
     * before the user authenticates.
     *
     * <p>From RFC-6120 ยง 7.1:</p>
     * <blockquote>
     * If, before completing the resource binding step, the client attempts
     * to send an XML stanza to an entity other than the server itself or
     * the client's account, the server MUST NOT process the stanza and MUST
     * close the stream with a <not-authorized/> stream error
     * (Section 4.9.3.12).
     * </blockquote>
     *
     * Ideally, we'd test this (too) after authentication but before resource binding, but the Smack API does not
     * support this.
     *
     * @throws InterruptedException if the calling thread was interrupted.
     * @throws XMPPException if an XMPP protocol error was received.
     * @throws IOException if an I/O error occurred.
     * @throws SmackException if Smack detected an exceptional situation.
     * @see <a href="https://igniterealtime.atlassian.net/jira/software/c/projects/OF/issues/OF-2565">issue OF-2565</a>
     */
    @SmackIntegrationTest
    public void testSendStanzaBeforeLoginToSelf() throws XMPPException, SmackException, IOException, InterruptedException
    {
        final AbstractXMPPConnection connection = getUnconnectedConnection();
        connection.connect();

        // connection.getUser() will be null prior to resource binding.
        final DomainBareJid server = connection.getXMPPServiceDomain();
        final BareJid self = JidCreate.bareFrom(Localpart.from(connection.config.getUsername().toString()), server);

        try {
            final IQ query = Version.builder(connection)
                .ofType(IQ.Type.get)
                .to(null) // Prior to authentication, user cannot verify the expected JID. Null implies 'addressed to self'.
                .build();

            // This basically is IQReplyFilter, but without the requirement that the connection is authenticated.
            final StanzaFilter filter = stanza -> new AndFilter(
                new OrFilter(IQTypeFilter.ERROR, IQTypeFilter.RESULT),
                new StanzaIdFilter(query),
                new OrFilter(FromMatchesFilter.createBare(self),
                    FromMatchesFilter.createFull(server),
                    FromMatchesFilter.createFull(null))
            ).test(stanza);

            final StanzaCollector collector = connection.createStanzaCollectorAndSend(filter, query);
            final IQ response = collector.nextResult();

            // It doesn't really matter if the response is a result or error. Receiving a response indicates that the
            // server has processed the request, instead of closing the stream.
            assertNotNull(response);
        } finally {
            connection.disconnect();
        }
    }

    /**
     * Asserts that the stream is NOT closed (with a 'not_authorized' stream error) when a stanza is sent to the server
     * itself, before the user authenticates.
     *
     * <p>From RFC-6120 ยง 7.1:</p>
     * <blockquote>
     * If, before completing the resource binding step, the client attempts
     * to send an XML stanza to an entity other than the server itself or
     * the client's account, the server MUST NOT process the stanza and MUST
     * close the stream with a <not-authorized/> stream error
     * (Section 4.9.3.12).
     * </blockquote>
     *
     * Ideally, we'd test this (too) after authentication but before resource binding, but the Smack API does not
     * support this.
     *
     * @throws InterruptedException if the calling thread was interrupted.
     * @throws XMPPException if an XMPP protocol error was received.
     * @throws IOException if an I/O error occurred.
     * @throws SmackException if Smack detected an exceptional situation.
     * @see <a href="https://igniterealtime.atlassian.net/jira/software/c/projects/OF/issues/OF-2565">issue OF-2565</a>
     */
    @SmackIntegrationTest
    public void testSendStanzaBeforeLoginServer() throws XMPPException, SmackException, IOException, InterruptedException
    {
        final AbstractXMPPConnection connection = getUnconnectedConnection();
        connection.connect();

        // connection.getUser() will be null prior to resource binding.
        final DomainBareJid server = connection.getXMPPServiceDomain();
        final BareJid self = JidCreate.bareFrom(Localpart.from(connection.config.getUsername().toString()), server);

        try {
            final IQ query = Version.builder(connection)
                .ofType(IQ.Type.get)
                .to(server)
                .build();

            // This basically is IQReplyFilter, but without the requirement that the connection is authenticated.
            final StanzaFilter filter = stanza -> new AndFilter(
                new OrFilter(IQTypeFilter.ERROR, IQTypeFilter.RESULT),
                new StanzaIdFilter(query),
                new OrFilter(FromMatchesFilter.createBare(self),
                    FromMatchesFilter.createFull(server),
                    FromMatchesFilter.createFull(null))
            ).test(stanza);

            final StanzaCollector collector = connection.createStanzaCollectorAndSend(filter, query);
            final IQ response = collector.nextResult();

            // It doesn't really matter if the response is a result or error. Receiving a response indicates that the
            // server has processed the request, instead of closing the stream.
            assertNotNull(response);
        } finally {
            connection.disconnect();
        }
    }
}
